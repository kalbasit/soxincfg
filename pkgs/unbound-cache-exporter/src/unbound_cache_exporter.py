#!/usr/bin/env python3
"""
Fetches DNS records from the Unbound cache, filters them using the Public
Suffix List to get a clean list of registrable domains, and writes them to
a specified output file.
"""

import os
import subprocess
import sys
from datetime import datetime, timezone

from publicsuffixlist import PublicSuffixList

# The path to the Unbound configuration file, needed for unbound-control.
UNBOUND_CONFIG_PATH = "/etc/unbound/unbound.conf"


def process_cache_dump(cache_dump: str) -> list[str]:
    """
    Takes the raw output from 'unbound-control dump_cache' and returns a
    clean, sorted list of valid, registrable domain names.
    """
    psl = PublicSuffixList()
    valid_domains = set()

    for line in cache_dump.splitlines():
        if not line.startswith("msg"):
            continue
        parts = line.split()
        if len(parts) < 2:
            continue
        domain = parts[1].strip().rstrip(".")
        if not domain:
            continue
        public_suffix = psl.publicsuffix(domain)
        if domain != public_suffix:
            valid_domains.add(domain)

    return sorted(list(valid_domains))


def main():
    """Main execution function."""
    # Get output path from command-line argument ---
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <output_file_path>", file=sys.stderr)
        sys.exit(1)
    output_file = sys.argv[1]

    print("Exporting and filtering active domains from Unbound cache...")

    try:
        proc = subprocess.run(
            f"unbound-control -c {UNBOUND_CONFIG_PATH} dump_cache",
            shell=True,
            check=True,
            capture_output=True,
            text=True,
        )
        cache_dump = proc.stdout
    except subprocess.CalledProcessError as e:
        print(f"Error running unbound-control: {e.stderr}", file=sys.stderr)
        sys.exit(1)

    clean_domains = process_cache_dump(cache_dump)

    try:
        with open(output_file, "w") as f:
            f.write(
                f"# Generated by {os.uname().nodename} on {datetime.now(timezone.utc).isoformat()}\n"
            )
            for domain in clean_domains:
                f.write(f"{domain}\n")
        print(f"Active domains list successfully updated at {output_file}")
    except IOError as e:
        print(f"Error writing to {output_file}: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
